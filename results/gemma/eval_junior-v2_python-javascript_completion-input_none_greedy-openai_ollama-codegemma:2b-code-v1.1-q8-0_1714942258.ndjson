{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "python", "prompt": "# a python function with input n that returns the factorial of n using iteration\ndef factorial(n):", "answer": "def factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\nn = int(input(\"Enter a number: \"))\nprint(f\"The factorial of {n} is {factorial(n)}\")\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\nn = int(input(\"Enter a number: \"))\nprint(f\"The factorial of {n} is {factorial(n)}\")", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "javascript", "prompt": "// a javascript function with input n that returns the factorial of n using iteration\nfunction factorial(n) {", "answer": "\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "python", "prompt": "# a python function with input n that returns the factorial of n using recursion\ndef factorial(n):", "answer": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nn = int(input(\"Enter a number: \"))\nprint(\"The factorial of\", n, \"is\", factorial(n))\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nn = int(input(\"Enter a number: \"))\nprint(\"The factorial of\", n, \"is\", factorial(n))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "javascript", "prompt": "// a javascript function with input n that returns the factorial of n using recursion\nfunction factorial(n) {", "answer": "\nfunction factorial(n) {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function factorial(n) {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "python", "prompt": "# a python function with input bork that returns the factorial of bork\ndef glork(bork):", "answer": "def glork(bork):\n    if bork == 0:\n        return 1\n    else:\n        return bork * glork(bork - 1)\n\nbork = int(input(\"Enter a number: \"))\nprint(\"The factorial of\", bork, \"is\", glork(bork))\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def glork(bork):\n    if bork == 0:\n        return 1\n    else:\n        return bork * glork(bork - 1)\n\nbork = int(input(\"Enter a number: \"))\nprint(\"The factorial of\", bork, \"is\", glork(bork))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "javascript", "prompt": "// a javascript function with input bork that returns the factorial of bork\nfunction glork(bork) {", "answer": "\nfunction glork(bork) {\n  // initialize the factorial to 1\n  let factorial = 1;\n  // loop through the numbers from 1 to bork\n  for (let i = 1; i <= bork; i++) {\n    // multiply the factorial by the current number\n    factorial *= i;\n  }\n  // return the factorial\n  return factorial;\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function glork(bork) {\n  // initialize the factorial to 1\n  let factorial = 1;\n  // loop through the numbers from 1 to bork\n  for (let i = 1; i <= bork; i++) {\n    // multiply the factorial by the current number\n    factorial *= i;\n  }\n  // return the factorial\n  return factorial;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "python", "prompt": "# a python function with two inputs a and b that returns the greatest common denominator of a and b\ndef gcd(a, b):", "answer": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcd", "got": "gcd", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "javascript", "prompt": "// a javascript function with two inputs a and b that returns the greatest common denominator of a and b\nfunction gcd(a, b) {", "answer": "\nfunction gcd(a, b) {\n  if (b === 0) {\n    return a;\n  } else {\n    return gcd(b, a % b);\n  }\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function gcd(a, b) {\n  if (b === 0) {\n    return a;\n  } else {\n    return gcd(b, a % b);\n  }\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcd", "got": "gcd", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "python", "prompt": "# a python function with two inputs a and b that returns the greatest common factor of a and b\ndef gcf(a, b):", "answer": "def gcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcf(b, a % b)\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def gcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcf(b, a % b)", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcf", "got": "gcf", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "javascript", "prompt": "// a javascript function with two inputs a and b that returns the greatest common factor of a and b\nfunction gcf(a, b) {", "answer": "\nfunction gcf(a, b) {\n  // if a is greater than b, swap the values of a and b\n  if (a > b) {\n    var temp = a;\n    a = b;\n    b = temp;\n  }\n  // loop through all numbers from 1 to a and check if they are factors of a and b\n  for (var i = 1; i <= a; i++) {\n    if (a % i == 0 && b % i == 0) {\n      // if i is a factor of both a and b, i is the greatest common factor\n      return i;\n    }\n  }\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function gcf(a, b) {\n  // if a is greater than b, swap the values of a and b\n  if (a > b) {\n    var temp = a;\n    a = b;\n    b = temp;\n  }\n  // loop through all numbers from 1 to a and check if they are factors of a and b\n  for (var i = 1; i <= a; i++) {\n    if (a % i == 0 && b % i == 0) {\n      // if i is a factor of both a and b, i is the greatest common factor\n      return i;\n    }\n  }\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 1, "status": 0}, {"assert": "f.call(5,0)", "eq": 5, "got": "Expecting value: line 1 column 1 (char 0)", "status": 0}, {"assert": "f.call(0,3)", "eq": 3, "got": "Expecting value: line 1 column 1 (char 0)", "status": 0}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcf", "got": "gcf", "status": 1}], "status": "FAIL", "passed": 6, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "python", "prompt": "# a python function with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana\ndef fofx(x, banana):", "answer": "def fofx(x, banana):\n    if x > banana:\n        while x % banana != 0:\n            x, banana = banana, x % banana\n        return banana\n    else:\n        while banana % x != 0:\n            x, banana = banana, x % banana\n        return x\nprint(fofx(10, 5))\nprint(fofx(10, 15))\nprint(fofx(10, 20))\nprint(fofx(10, 25))\nprint(fofx(10, 30))\nprint(fofx(10, 35))\nprint(fofx(10, 40))\nprint(fofx(10, 45))\nprint(fofx(10, 50))\nprint(fofx(10, 55))\nprint(fofx(10, 60))\nprint(fofx(10, 65))\nprint(fofx(10, 70))\nprint(fofx(10, 75))\nprint(fofx(10, 80))\nprint(fofx(10, 85))\nprint(fofx(10, 90))\nprint(fofx(10, 95))\nprint(fofx(10, 100))\nprint(fofx(10, 105))\nprint(fofx(10, 110))\nprint(fofx(10, 115))\nprint(fofx(10, 120))\nprint(fofx(10, 125))\nprint(fofx(10, 130))\nprint(fofx(10, 135))\nprint(fofx(10, 140))\nprint(fofx(10, 145))\nprint(fofx(10, 150))\nprint(fofx(10, 155))\nprint(fofx(10, 160))\nprint(fofx(10, 165))\nprint(fofx(10, 170))\nprint(fofx(10, 175))\nprint(fofx(10, 180))\nprint(fofx(10, 185))\nprint(fofx(10, 190))\nprint(fofx(10, 195))\nprint(fofx(10, 200))\nprint(fofx(10, 205))\nprint(fofx(10, 210))\nprint(fofx(10, 215))\nprint(fofx(10, 220))\nprint(fofx(10, 225))\nprint(fofx(10, 230))\nprint(fofx(10, 235))\nprint(fofx(10, 240))\nprint(fofx(10, 245))\nprint(fofx(10, 250))\nprint(fofx(10, 255))\nprint(fofx(10, 260))\nprint(fofx(10, 265))\nprint(fofx(10, 270))\nprint(fofx(10, 275))\nprint(fofx(10, 280))\nprint(fofx(10, 285))\nprint(fofx(10, 290))\nprint(fofx(10, 295))\nprint(fofx(10, 300))\nprint(fofx(10, 305))\nprint(fofx(10, 310))\nprint(fofx(10, 315))\nprint(fofx(10, 320))\nprint(fofx(10, 325))\nprint(fofx(10, 330))\nprint(fofx(\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def fofx(x, banana):\n    if x > banana:\n        while x % banana != 0:\n            x, banana = banana, x % banana\n        return banana\n    else:\n        while banana % x != 0:\n            x, banana = banana, x % banana\n        return x\nprint(fofx(10, 5))\nprint(fofx(10, 15))\nprint(fofx(10, 20))\nprint(fofx(10, 25))\nprint(fofx(10, 30))\nprint(fofx(10, 35))\nprint(fofx(10, 40))\nprint(fofx(10, 45))\nprint(fofx(10, 50))\nprint(fofx(10, 55))\nprint(fofx(10, 60))\nprint(fofx(10, 65))\nprint(fofx(10, 70))\nprint(fofx(10, 75))\nprint(fofx(10, 80))\nprint(fofx(10, 85))\nprint(fofx(10, 90))\nprint(fofx(10, 95))\nprint(fofx(10, 100))\nprint(fofx(10, 105))\nprint(fofx(10, 110))\nprint(fofx(10, 115))\nprint(fofx(10, 120))\nprint(fofx(10, 125))\nprint(fofx(10, 130))\nprint(fofx(10, 135))\nprint(fofx(10, 140))\nprint(fofx(10, 145))\nprint(fofx(10, 150))\nprint(fofx(10, 155))\nprint(fofx(10, 160))\nprint(fofx(10, 165))\nprint(fofx(10, 170))\nprint(fofx(10, 175))\nprint(fofx(10, 180))\nprint(fofx(10, 185))\nprint(fofx(10, 190))\nprint(fofx(10, 195))\nprint(fofx(10, 200))\nprint(fofx(10, 205))\nprint(fofx(10, 210))\nprint(fofx(10, 215))\nprint(fofx(10, 220))\nprint(fofx(10, 225))\nprint(fofx(10, 230))\nprint(fofx(10, 235))\nprint(fofx(10, 240))\nprint(fofx(10, 245))\nprint(fofx(10, 250))\nprint(fofx(10, 255))\nprint(fofx(10, 260))\nprint(fofx(10, 265))\nprint(fofx(10, 270))\nprint(fofx(10, 275))\nprint(fofx(10, 280))\nprint(fofx(10, 285))\nprint(fofx(10, 290))\nprint(fofx(10, 295))\nprint(fofx(10, 300))\nprint(fofx(10, 305))\nprint(fofx(10, 310))\nprint(fofx(10, 315))\nprint(fofx(10, 320))\nprint(fofx(10, 325))\nprint(fofx(10, 330))\nprint(fofx(", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": {"error": "unexpected EOF while parsing (<string>, line 75)", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(100,20)", "eq": 20, "got": {"error": "unexpected EOF while parsing (<string>, line 75)", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(5,0)", "eq": 5, "got": {"error": "unexpected EOF while parsing (<string>, line 75)", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(0,3)", "eq": 3, "got": {"error": "unexpected EOF while parsing (<string>, line 75)", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(13,7)", "eq": 1, "got": {"error": "unexpected EOF while parsing (<string>, line 75)", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "fofx", "status": 1}], "status": "FAIL", "passed": 4, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "javascript", "prompt": "// a javascript function with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana\nfunction fofx(x, banana) {", "answer": "\nfunction fofx(x, banana) {\n  // if x is less than banana, swap the values\n  if (x < banana) {\n    var temp = x;\n    x = banana;\n    banana = temp;\n  }\n\n  // loop through the numbers from 1 to the smaller of x and banana\n  for (var i = 1; i <= Math.min(x, banana); i++) {\n    // if i is a factor of both x and banana, it's the gcd\n    if (x % i == 0 && banana % i == 0) {\n      return i;\n    }\n  }\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function fofx(x, banana) {\n  // if x is less than banana, swap the values\n  if (x < banana) {\n    var temp = x;\n    x = banana;\n    banana = temp;\n  }\n\n  // loop through the numbers from 1 to the smaller of x and banana\n  for (var i = 1; i <= Math.min(x, banana); i++) {\n    // if i is a factor of both x and banana, it's the gcd\n    if (x % i == 0 && banana % i == 0) {\n      return i;\n    }\n  }\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 1, "status": 0}, {"assert": "f.call(5,0)", "eq": 5, "got": "Expecting value: line 1 column 1 (char 0)", "status": 0}, {"assert": "f.call(0,3)", "eq": 3, "got": "Expecting value: line 1 column 1 (char 0)", "status": 0}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "fofx", "status": 1}], "status": "FAIL", "passed": 6, "total": 9}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "python", "prompt": "# a python function with no inputs that returns a single integer, the answer to life the universe and everything given the answer to life the universe and everything is 42\ndef meaning_of_life():", "answer": "def meaning_of_life():\n    return 42\nprint(meaning_of_life())\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def meaning_of_life():\n    return 42\nprint(meaning_of_life())", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "javascript", "prompt": "// a javascript function with no inputs that returns a single integer, the answer to life the universe and everything given the answer to life the universe and everything is 42\nfunction meaning_of_life() {", "answer": "\nfunction meaning_of_life() {\n    return 42;\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function meaning_of_life() {\n    return 42;\n}", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "python", "prompt": "# a python function with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain given the capital city of Spain is Madrid\ndef things():", "answer": "def things():\n    return [5, 'foobar', 'Madrid']\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def things():\n    return [5, 'foobar', 'Madrid']", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "javascript", "prompt": "// a javascript function with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain given the capital city of Spain is Madrid\nfunction things() {", "answer": "\nfunction things() {\n  return [5, 'foobar', 'Madrid'];\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function things() {\n  return [5, 'foobar', 'Madrid'];\n}", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "python", "prompt": "# a python function with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names given Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.\ndef secretidentities():", "answer": "def secretidentities():\n    return {\n        \"Superman\": \"Clark Kent\",\n        \"Batman\": \"Bruce Wayne\",\n        \"Spider-Man\": \"Peter Parker\"\n    }\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def secretidentities():\n    return {\n        \"Superman\": \"Clark Kent\",\n        \"Batman\": \"Bruce Wayne\",\n        \"Spider-Man\": \"Peter Parker\"\n    }", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": "Clark Kent", "status": 1}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "Bruce Wayne", "status": 1}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": "Peter Parker", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "javascript", "prompt": "// a javascript function with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names given Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.\nfunction secretidentities() {", "answer": "\nfunction secretidentities() {\n    return {\n        Superman: \"Clark Kent\",\n        Batman: \"Bruce Wayne\",\n        Spiderman: \"Peter Parker\"\n    };\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function secretidentities() {\n    return {\n        Superman: \"Clark Kent\",\n        Batman: \"Bruce Wayne\",\n        Spiderman: \"Peter Parker\"\n    };\n}", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": "Clark Kent", "status": 1}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "Bruce Wayne", "status": 1}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": null, "status": 0}], "status": "FAIL", "passed": 4, "total": 5}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "python", "prompt": "# a python function with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef fib(n):", "answer": "def fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "javascript", "prompt": "// a javascript function with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction fib(n) {", "answer": "\nfunction fib(n) {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function fib(n) {\n    if (n === 0) {\n        return 0;\n    } else if (n === 1) {\n        return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "python", "prompt": "# a python function with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef potato(g):", "answer": "def potato(g):\n    if g == 0:\n        return 0\n    elif g == 1:\n        return 1\n    else:\n        return potato(g-1) + potato(g-2)\nprint(potato(10))\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def potato(g):\n    if g == 0:\n        return 0\n    elif g == 1:\n        return 1\n    else:\n        return potato(g-1) + potato(g-2)\nprint(potato(10))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "javascript", "prompt": "// a javascript function with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction potato(g) {", "answer": "\nfunction potato(g) {\n    let fib = [0, 1];\n    for (let i = 2; i <= g; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2];\n    }\n    return fib[g];\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function potato(g) {\n    let fib = [0, 1];\n    for (let i = 2; i <= g; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2];\n    }\n    return fib[g];\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "python", "prompt": "# a python function with input length n that returns a list with the first `n` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef fib(n):", "answer": "def fib(n):\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\n\ndef fibonacci_sequence(n):\n    sequence = []\n    for i in range(n):\n        sequence.append(fib(i))\n    return sequence\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def fib(n):\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\n\ndef fibonacci_sequence(n):\n    sequence = []\n    for i in range(n):\n        sequence.append(fib(i))\n    return sequence", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": false, "status": 0}, {"assert": "f.call(1)", "eq": [0], "got": 1, "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": 1, "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": 2, "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": 5, "status": 0}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 2, "total": 7}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "javascript", "prompt": "// a javascript function with input length n that returns a list with the first `n` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction fib(n) {", "answer": "\nfunction fib(n) {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function fib(n) {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": false, "status": 0}, {"assert": "f.call(1)", "eq": [0], "got": 1, "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": 1, "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": 2, "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": 5, "status": 0}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 2, "total": 7}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "python", "prompt": "# a python function with input length bork that returns a list with the first `bork` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef glork(bork):", "answer": "def glork(bork):\n    if bork == 0:\n        return [0]\n    elif bork == 1:\n        return [0, 1]\n    else:\n        fib_sequence = [0, 1]\n        for i in range(2, bork):\n            fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])\n        return fib_sequence\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def glork(bork):\n    if bork == 0:\n        return [0]\n    elif bork == 1:\n        return [0, 1]\n    else:\n        fib_sequence = [0, 1]\n        for i in range(2, bork):\n            fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])\n        return fib_sequence", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0, 1], "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "FAIL", "passed": 7, "total": 8}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "javascript", "prompt": "// a javascript function with input length bork that returns a list with the first `bork` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction glork(bork) {", "answer": "\nfunction glork(bork) {\n  let fib = [0, 1];\n  for (let i = 2; i < bork; i++) {\n    fib[i] = fib[i - 1] + fib[i - 2];\n  }\n  return fib;\n}\nconsole.log(glork(10)); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function glork(bork) {\n  let fib = [0, 1];\n  for (let i = 2; i < bork; i++) {\n    fib[i] = fib[i - 1] + fib[i - 2];\n  }\n  return fib;\n}\nconsole.log(glork(10)); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0, 1], "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "FAIL", "passed": 7, "total": 8}
{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "python", "prompt": "# a python function with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`\ndef substrcount(str, substr):", "answer": "def substrcount(str, substr):\n    count = 0\n    for i in range(len(str)):\n        if str[i:i+len(substr)] == substr:\n            count += 1\n    return count\n", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "def substrcount(str, substr):\n    count = 0\n    for i in range(len(str)):\n        if str[i:i+len(substr)] == substr:\n            count += 1\n    return count", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "javascript", "prompt": "// a javascript function with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`\nfunction substrcount(str, substr) {", "answer": "\nfunction substrcount(str, substr) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.slice(i, i + substr.length) === substr) {\n      count++;\n    }\n  }\n  return count;\n}", "params": {"temperature": 0.0, "max_tokens": 1024, "stop": ["<|file_separator|>", "\n#", "\n//"]}, "model": "ollama/codegemma:2b-code-v1.1-q8_0", "runtime": "ollama", "code": "function substrcount(str, substr) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.slice(i, i + substr.length) === substr) {\n      count++;\n    }\n  }\n  return count;\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}