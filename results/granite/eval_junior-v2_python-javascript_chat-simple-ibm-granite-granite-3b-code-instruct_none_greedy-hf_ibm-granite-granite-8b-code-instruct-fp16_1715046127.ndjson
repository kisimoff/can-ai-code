{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "python", "prompt": "Question:\nWrite a python function factorial(n) with input n that returns the factorial of n using iteration\n\nAnswer:\n", "answer": "Here's how you could implement the factorial function using iteration:\n\n```python\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n```\n\nThis function uses a for loop to iterate over the range from 1 to n, multiplying each number to the result variable. The result variable is initialized to 1, and at the end of the loop, it contains the factorial of n.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "javascript", "prompt": "Question:\nWrite a javascript function factorial(n) with input n that returns the factorial of n using iteration\n\nAnswer:\n", "answer": "Here's an example of a factorial function in JavaScript that uses iteration:\n\n```javascript\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n```\n\nThis function uses a for loop to iterate from 1 to n, multiplying each number to the result variable. The result variable is initialized to 1, and each multiplication updates its value. Finally, the function returns the result.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "python", "prompt": "Question:\nWrite a python function factorial(n) with input n that returns the factorial of n using recursion\n\nAnswer:\n", "answer": "Here's an example of a Python function that calculates the factorial of a number using recursion:\n\n```python\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n```\n\nThis function uses recursion to calculate the factorial of a number. It checks if the input number is 0, and if so, returns 1. Otherwise, it multiplies the input number by the factorial of n-1, which is calculated by calling the factorial function recursively.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "javascript", "prompt": "Question:\nWrite a javascript function factorial(n) with input n that returns the factorial of n using recursion\n\nAnswer:\n", "answer": "Here's an example of a recursive function that calculates the factorial of a number:\n\n```javascript\nfunction factorial(n) {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n```\n\nThis function checks if the input number is 0. If it is, it returns 1, which is the base case for the factorial. If the input number is not 0, it multiplies the input number by the factorial of n-1, which is the recursive case. This process continues until the base case is reached.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function factorial(n) {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "python", "prompt": "Question:\nWrite a python function glork(bork) with input bork that returns the factorial of bork\n\nAnswer:\n", "answer": "Here's a Python function that implements the factorial function:\n\n```python\ndef glork(bork):\n    if bork < 0:\n        raise ValueError(\"bork must be a non-negative integer\")\n    elif bork == 0:\n        return 1\n    else:\n        return bork * glork(bork - 1)\n```\n\nThis function uses recursion to calculate the factorial of a given number. If the input is negative, it raises a ValueError. If the input is 0, it returns 1. Otherwise, it multiplies the input by the factorial of the input minus 1.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def glork(bork):\n    if bork < 0:\n        raise ValueError(\"bork must be a non-negative integer\")\n    elif bork == 0:\n        return 1\n    else:\n        return bork * glork(bork - 1)", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "javascript", "prompt": "Question:\nWrite a javascript function glork(bork) with input bork that returns the factorial of bork\n\nAnswer:\n", "answer": "Here's a JavaScript function that calculates the factorial of a number:\n\n```javascript\nfunction glork(bork) {\n  if (bork < 0) {\n    return \"Factorial is not defined for negative numbers\";\n  } else if (bork === 0) {\n    return 1;\n  } else {\n    let result = 1;\n    for (let i = 1; i <= bork; i++) {\n      result *= i;\n    }\n    return result;\n  }\n}\n```\n\nThis function checks if the input number is negative, zero, or positive. If it's negative, it returns an error message. If it's zero, it returns 1. Otherwise, it calculates the factorial by multiplying all the numbers from 1 to the input number.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function glork(bork) {\n  if (bork < 0) {\n    return \"Factorial is not defined for negative numbers\";\n  } else if (bork === 0) {\n    return 1;\n  } else {\n    let result = 1;\n    for (let i = 1; i <= bork; i++) {\n      result *= i;\n    }\n    return result;\n  }\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "python", "prompt": "Question:\nWrite a python function gcd(a, b) with two inputs a and b that returns the greatest common denominator of a and b\n\nAnswer:\n", "answer": "Here's how you could implement the function:\n\n```python\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcd", "got": "gcd", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "javascript", "prompt": "Question:\nWrite a javascript function gcd(a, b) with two inputs a and b that returns the greatest common denominator of a and b\n\nAnswer:\n", "answer": "Here's a JavaScript function that implements the Euclidean algorithm to find the greatest common denominator (GCD) of two numbers:\n\n```javascript\nfunction gcd(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n```\n\nThe Euclidean algorithm is a recursive algorithm that works by repeatedly dividing the larger number by the smaller number and taking the remainder. The GCD is the last non-zero remainder.\n\nThe function takes two inputs, a and b, and returns the GCD of a and b. If b is 0, then a is the GCD, so we return a. Otherwise, we call the function recursively with b and the remainder of a divided by b. This process continues until b is 0, at which point we return a.\n\nHere's an example of how to use the function:\n\n```javascript\nconsole.log(gcd(12, 18)); // Output: 6\nconsole.log(gcd(48, 18)); // Output: 6\nconsole.log(gcd(15, 10)); // Output: 5\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function gcd(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcd", "got": "gcd", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "python", "prompt": "Question:\nWrite a python function gcf(a, b) with two inputs a and b that returns the greatest common factor of a and b\n\nAnswer:\n", "answer": "Here's how you could implement the function gcf(a, b):\n\n```python\ndef gcf(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def gcf(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcf", "got": "gcf", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "javascript", "prompt": "Question:\nWrite a javascript function gcf(a, b) with two inputs a and b that returns the greatest common factor of a and b\n\nAnswer:\n", "answer": "Here's a JavaScript function that implements the Euclidean algorithm to find the greatest common factor (GCF) of two numbers:\n\n```javascript\nfunction gcf(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return gcf(b, a % b);\n}\n```\n\nThe Euclidean algorithm is a recursive algorithm that works by repeatedly dividing the larger number by the smaller number and taking the remainder. The GCF is the largest number that divides both a and b without leaving a remainder.\n\nThe function takes two inputs, a and b, and returns the GCF of the two numbers. If b is 0, then a is the GCF, so we return a. Otherwise, we call the function recursively with b and the remainder of a divided by b. This process continues until b is 0, at which point we return a.\n\nHere's an example of how to use the function:\n\n```javascript\nconsole.log(gcf(12, 18)); // Output: 6\nconsole.log(gcf(24, 36)); // Output: 12\nconsole.log(gcf(48, 60)); // Output: 12\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function gcf(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return gcf(b, a % b);\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcf", "got": "gcf", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "python", "prompt": "Question:\nWrite a python function fofx(x, banana) with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana\n\nAnswer:\n", "answer": "Here's how you can implement the function:\n\n```python\nimport math\n\ndef fofx(x, banana):\n    return math.gcd(x, banana)\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "import math\n\ndef fofx(x, banana):\n    return math.gcd(x, banana)", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "fofx", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "javascript", "prompt": "Question:\nWrite a javascript function fofx(x, banana) with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana\n\nAnswer:\n", "answer": "Here's a JavaScript function that implements the Euclidean algorithm to find the greatest common denominator (gcd) of two numbers:\n\n```javascript\nfunction gcd(x, y) {\n  if (y === 0) {\n    return x;\n  } else {\n    return gcd(y, x % y);\n  }\n}\n\nfunction fofx(x, banana) {\n  return gcd(x, banana);\n}\n```\n\nThe `gcd` function recursively calculates the gcd of two numbers using the Euclidean algorithm. The `fofx` function simply calls the `gcd` function with the two inputs.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function gcd(x, y) {\n  if (y === 0) {\n    return x;\n  } else {\n    return gcd(y, x % y);\n  }\n}\n\nfunction fofx(x, banana) {\n  return gcd(x, banana);\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "y", "status": 0}, {"assert": "f.name", "eq": "fofx", "got": "gcd", "status": 0}], "status": "FAIL", "passed": 7, "total": 9}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "python", "prompt": "Question:\nWrite a python function meaning_of_life() with no inputs that returns a single integer, the answer to life the universe and everything\n\nAnswer:\n", "answer": "Here's a Python function that returns the answer to the ultimate question of life, the universe, and everything:\n\n```python\ndef meaning_of_life():\n    return 42\n```\n\nThis function simply returns the integer 42, which is the answer to the ultimate question of life, the universe, and everything.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def meaning_of_life():\n    return 42", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "javascript", "prompt": "Question:\nWrite a javascript function meaning_of_life() with no inputs that returns a single integer, the answer to life the universe and everything\n\nAnswer:\n", "answer": "Here's a possible implementation of the function:\n\n```javascript\nfunction meaning_of_life() {\n  return 42;\n}\n```\n\nThis function simply returns the integer 42, which is the answer to the ultimate question of life, the universe, and everything.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function meaning_of_life() {\n  return 42;\n}", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "python", "prompt": "Question:\nWrite a python function things() with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain\n\nAnswer:\n", "answer": "Here's an example of how you could write the function:\n\n```python\ndef things():\n    return [5, 'foobar', 'Madrid']\n```\n\nThis function returns a list with three values: the number 5, the string 'foobar', and the capital city of Spain, which is 'Madrid'.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def things():\n    return [5, 'foobar', 'Madrid']", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "javascript", "prompt": "Question:\nWrite a javascript function things() with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain\n\nAnswer:\n", "answer": "Here's an example of a JavaScript function that returns a list with three values:\n\n```javascript\nfunction things() {\n  return [5, 'foobar', 'Madrid'];\n}\n```\n\nThis function returns an array with three values: the number 5, the string 'foobar', and the capital city of Spain, which is 'Madrid'.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function things() {\n  return [5, 'foobar', 'Madrid'];\n}", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "python", "prompt": "Question:\nWrite a python function secretidentities() with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names\n\nAnswer:\n", "answer": "Here's an example implementation of the `secretidentities()` function:\n\n```python\ndef secretidentities():\n    return {\n        \"Superman\": \"Clark Kent\",\n        \"Batman\": \"Bruce Wayne\",\n        \"Spider-Man\": \"Peter Parker\"\n    }\n```\n\nThis function returns a dictionary mapping the superheroes to their real names.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def secretidentities():\n    return {\n        \"Superman\": \"Clark Kent\",\n        \"Batman\": \"Bruce Wayne\",\n        \"Spider-Man\": \"Peter Parker\"\n    }", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": "Clark Kent", "status": 1}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "Bruce Wayne", "status": 1}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": "Peter Parker", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "javascript", "prompt": "Question:\nWrite a javascript function secretidentities() with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names\n\nAnswer:\n", "answer": "Here's an example of how you could write the function:\n\n```javascript\nfunction secretidentities() {\n  return {\n    Superman: 'Clark Kent',\n    Batman: 'Bruce Wayne',\n    'Spider-Man': 'Peter Parker'\n  };\n}\n```\n\nThis function returns an object with the superheroes as keys and their real names as values.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function secretidentities() {\n  return {\n    Superman: 'Clark Kent',\n    Batman: 'Bruce Wayne',\n    'Spider-Man': 'Peter Parker'\n  };\n}", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": "Clark Kent", "status": 1}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "Bruce Wayne", "status": 1}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": "Peter Parker", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "python", "prompt": "Question:\nWrite a python function fib(n) with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's how you can implement the `fib` function in Python:\n\n```python\ndef fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n```\n\nThe `fib` function uses recursion to calculate the `n`-th element of the Fibonacci sequence. It checks if `n` is 0 or 1, and returns the corresponding value. Otherwise, it recursively calls itself with `n - 1` and `n - 2` as arguments, and returns the sum of the two previous elements.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "javascript", "prompt": "Question:\nWrite a javascript function fib(n) with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's a JavaScript function that implements the Fibonacci sequence:\n\n```javascript\nfunction fib(n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n```\n\nThis function uses recursion to calculate the `n`-th element of the Fibonacci sequence. If `n` is less than or equal to 1, the function returns `n`. Otherwise, it recursively calls itself with `n - 1` and `n - 2` as arguments, and returns the sum of the two previous elements.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function fib(n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "python", "prompt": "Question:\nWrite a python function potato(g) with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's how you can implement the `potato` function in Python:\n\n```python\ndef potato(g):\n    if g == 0:\n        return 0\n    elif g == 1:\n        return 1\n    else:\n        return potato(g - 1) + potato(g - 2)\n```\n\nThe `potato` function uses recursion to calculate the `g`-th element of the fibonacci sequence. It checks if `g` is 0 or 1, and returns the corresponding value. Otherwise, it recursively calls itself with `g - 1` and `g - 2` as arguments, and returns the sum of the two previous elements.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def potato(g):\n    if g == 0:\n        return 0\n    elif g == 1:\n        return 1\n    else:\n        return potato(g - 1) + potato(g - 2)", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "javascript", "prompt": "Question:\nWrite a javascript function potato(g) with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's a possible implementation of the `potato` function in JavaScript:\n\n```javascript\nfunction potato(g) {\n  let fibonacci = [0, 1];\n  for (let i = 2; i <= g; i++) {\n    fibonacci.push(fibonacci[i - 1] + fibonacci[i - 2]);\n  }\n  return fibonacci[g];\n}\n```\n\nThis function uses a loop to generate the first `g + 1` elements of the Fibonacci sequence and stores them in an array. It then returns the `g`-th element of the array.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function potato(g) {\n  let fibonacci = [0, 1];\n  for (let i = 2; i <= g; i++) {\n    fibonacci.push(fibonacci[i - 1] + fibonacci[i - 2]);\n  }\n  return fibonacci[g];\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "python", "prompt": "Question:\nWrite a python function fib(n) with input length n that returns a list with the first `n` elements of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's how you can implement the `fib` function in Python:\n\n```python\ndef fib(n):\n    fib_sequence = [0, 1]\n    for i in range(2, n):\n        fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])\n    return fib_sequence[:n]\n```\n\nThe `fib` function takes an input `n` and returns a list with the first `n` elements of the Fibonacci sequence. It initializes the list with the first two elements of the sequence, and then uses a loop to generate the remaining elements by adding the previous two elements. Finally, it returns a slice of the list containing the first `n` elements.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def fib(n):\n    fib_sequence = [0, 1]\n    for i in range(2, n):\n        fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])\n    return fib_sequence[:n]", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "javascript", "prompt": "Question:\nWrite a javascript function fib(n) with input length n that returns a list with the first `n` elements of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's how you can implement the `fib` function in JavaScript:\n\n```javascript\nfunction fib(n) {\n  const sequence = [0, 1];\n  for (let i = 2; i < n; i++) {\n    sequence.push(sequence[i - 1] + sequence[i - 2]);\n  }\n  return sequence;\n}\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function fib(n) {\n  const sequence = [0, 1];\n  for (let i = 2; i < n; i++) {\n    sequence.push(sequence[i - 1] + sequence[i - 2]);\n  }\n  return sequence;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0, 1], "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 6, "total": 7}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "python", "prompt": "Question:\nWrite a python function glork(bork) with input length bork that returns a list with the first `bork` elements of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's how you can implement the `glork` function in Python:\n\n```python\ndef glork(bork):\n    fibonacci_sequence = [0, 1]\n    for i in range(2, bork):\n        fibonacci_sequence.append(fibonacci_sequence[i - 1] + fibonacci_sequence[i - 2])\n    return fibonacci_sequence[:bork]\n```\n\nThe `glork` function takes an input `bork` and returns a list with the first `bork` elements of the fibonacci sequence. It initializes the fibonacci sequence with the first two elements, and then uses a for loop to generate the remaining elements by adding the previous two elements. Finally, it returns a slice of the fibonacci sequence with the first `bork` elements.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def glork(bork):\n    fibonacci_sequence = [0, 1]\n    for i in range(2, bork):\n        fibonacci_sequence.append(fibonacci_sequence[i - 1] + fibonacci_sequence[i - 2])\n    return fibonacci_sequence[:bork]", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "javascript", "prompt": "Question:\nWrite a javascript function glork(bork) with input length bork that returns a list with the first `bork` elements of the fibonacci sequence\n\nAnswer:\n", "answer": "Here's a possible implementation of the `glork` function in JavaScript:\n\n```javascript\nfunction glork(bork) {\n  let fibonacci = [0, 1];\n  for (let i = 2; i < bork; i++) {\n    fibonacci.push(fibonacci[i - 1] + fibonacci[i - 2]);\n  }\n  return fibonacci;\n}\n```\n\nThis function uses a loop to generate the first `bork` elements of the fibonacci sequence and returns them as an array.", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function glork(bork) {\n  let fibonacci = [0, 1];\n  for (let i = 2; i < bork; i++) {\n    fibonacci.push(fibonacci[i - 1] + fibonacci[i - 2]);\n  }\n  return fibonacci;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0, 1], "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "FAIL", "passed": 7, "total": 8}
{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "python", "prompt": "Question:\nWrite a python function substrcount(str, substr) with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`\n\nAnswer:\n", "answer": "Here's how you can implement the `substrcount` function in Python:\n\n```python\ndef substrcount(str, substr):\n    count = 0\n    for i in range(len(str) - len(substr) + 1):\n        if str[i:i+len(substr)] == substr:\n            count += 1\n    return count\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "def substrcount(str, substr):\n    count = 0\n    for i in range(len(str) - len(substr) + 1):\n        if str[i:i+len(substr)] == substr:\n            count += 1\n    return count", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "javascript", "prompt": "Question:\nWrite a javascript function substrcount(str, substr) with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`\n\nAnswer:\n", "answer": "Here's how you can implement the `substrcount` function in JavaScript:\n\n```javascript\nfunction substrcount(str, substr) {\n  let count = 0;\n  let index = str.indexOf(substr);\n  while (index !== -1) {\n    count++;\n    index = str.indexOf(substr, index + 1);\n  }\n  return count;\n}\n```", "params": "GenerationConfig {\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0,\n  \"use_cache\": false\n}\n", "model": "ibm-granite-granite-8b-code-instruct-fp16", "runtime": "transformers", "code": "function substrcount(str, substr) {\n  let count = 0;\n  let index = str.indexOf(substr);\n  while (index !== -1) {\n    count++;\n    index = str.indexOf(substr, index + 1);\n  }\n  return count;\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}